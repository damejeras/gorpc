// Code generated by gorpc; DO NOT EDIT.

package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
	"fmt"

	"github.com/pkg/errors"
	services "github.com/damejeras/gorpc/test/services"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost  string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient 	*http.Client
	// BeforeRequest is an optional hook that gives you the opportunity
	// to inspect or modify the request before it is made.
	// Useful for adding auth headers, for example.
	BeforeRequest func(r *http.Request) error
	// Debug writes a line of debug log output.
	Debug func(s string)
}

// New makes a new Client.
func New(remoteHost string) *Client {
	c := &Client{
		RemoteHost: remoteHost,
		Debug: func(s string) {},
		HTTPClient: &http.Client{Timeout:10*time.Second},
	}
	return c
}


// GreeterService is a polite API. You will love it.
type GreeterService struct {
	client *Client
}

// NewGreeterService makes a new client for accessing GreeterService services.
func NewGreeterService(client *Client) *GreeterService {
	return &GreeterService{
		client: client,
	}
}


// GetGreetings gets a range of saved Greetings.
func (s *GreeterService) GetGreetings(ctx context.Context, r GetGreetingsRequest) (*GetGreetingsResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.GetGreetings: marshal GetGreetingsRequest")
	}
	url := s.client.RemoteHost + "GreeterService.GetGreetings"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.GetGreetings: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.GetGreetings")
	}
	defer resp.Body.Close()
	var response struct {
		GetGreetingsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "GreeterService.GetGreetings: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.GetGreetings: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("GreeterService.GetGreetings: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetGreetingsResponse, nil
}

// Greet creates a Greeting for one or more people.
func (s *GreeterService) Greet(ctx context.Context, r GreetRequest) (*GreetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.Greet: marshal GreetRequest")
	}
	url := s.client.RemoteHost + "GreeterService.Greet"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.Greet: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.Greet")
	}
	defer resp.Body.Close()
	var response struct {
		GreetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "GreeterService.Greet: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "GreeterService.Greet: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("GreeterService.Greet: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GreetResponse, nil
}


// Ignorer gets ignored by the tooling.
type Ignorer struct {
	client *Client
}

// NewIgnorer makes a new client for accessing Ignorer services.
func NewIgnorer(client *Client) *Ignorer {
	return &Ignorer{
		client: client,
	}
}


func (s *Ignorer) Ignore(ctx context.Context, r IgnoreRequest) (*IgnoreResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "Ignorer.Ignore: marshal IgnoreRequest")
	}
	url := s.client.RemoteHost + "Ignorer.Ignore"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "Ignorer.Ignore: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Ignorer.Ignore")
	}
	defer resp.Body.Close()
	var response struct {
		IgnoreResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "Ignorer.Ignore: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "Ignorer.Ignore: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("Ignorer.Ignore: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.IgnoreResponse, nil
}


// Welcomer welcomes people.
type Welcomer struct {
	client *Client
}

// NewWelcomer makes a new client for accessing Welcomer services.
func NewWelcomer(client *Client) *Welcomer {
	return &Welcomer{
		client: client,
	}
}


// Welcome makes a welcome message for somebody.
func (s *Welcomer) Welcome(ctx context.Context, r WelcomeRequest) (*WelcomeResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "Welcomer.Welcome: marshal WelcomeRequest")
	}
	url := s.client.RemoteHost + "Welcomer.Welcome"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "Welcomer.Welcome: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "Welcomer.Welcome")
	}
	defer resp.Body.Close()
	var response struct {
		WelcomeResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "Welcomer.Welcome: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "Welcomer.Welcome: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("Welcomer.Welcome: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.WelcomeResponse, nil
}

// GetGreetingsRequest is the request object for GreeterService.GetGreetings.
type GetGreetingsRequest struct {
	// Page describes which page of data to get.
	Page services.Page `json:"page"`
	}
    
// GetGreetingsResponse is the respponse object for GreeterService.GetGreetings.
type GetGreetingsResponse struct {
		Greetings[] Greeting `json:"greetings"`
	}
    
// GreetRequest is the request object for GreeterService.Greet.
type GreetRequest struct {
	// Names are the names of the people to greet.
	Names[] string `json:"names"`
	}
    
// GreetResponse is the response object containing a person's greeting.
type GreetResponse struct {
	// Greeting is the generated Greeting.
	Greeting Greeting `json:"greeting"`
	}
    
// Greeting contains the pleasentry.
type Greeting struct {
	// Text is the message.
	Text string `json:"text"`
	}
    
// IgnoreRequest should get ignored.
type IgnoreRequest struct {
	}
    
// IgnoreResponse should get ignored.
type IgnoreResponse struct {
	}
    

// WelcomeRequest is the request object for Welcomer.Welcome.
type WelcomeRequest struct {
	// To is the address of the person to send the message to.
	To string `json:"to"`
	// Name is the name of the person to welcome.
	Name string `json:"name"`
	// The number of times to send the message.
	Times int `json:"times"`
	// NewCustomer indicates whether this is a new customer or not.
	NewCustomer bool `json:"newCustomer"`
	}
    
// WelcomeResponse is the response object for Welcomer.Welcome.
type WelcomeResponse struct {
	// Message is the welcome message.
	Message string `json:"message"`
	}
    
