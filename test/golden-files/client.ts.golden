// Code generated by gorpc; DO NOT EDIT.

// HeadersFunc allows you to mutate headers for each request.
// Useful for adding authorization into the client.
interface HeadersFunc {
	(headers: Headers): void;
}

// Client provides access to remote services.
export class Client {
	// basepath is the path prefix for the requests.
	// This may be a path, or an absolute URL.
	public basepath: String = '/gorpc/'
	// headers allows calling code to mutate the HTTP
	// headers of the underlying HTTP requests.
	public headers?: HeadersFunc
}


// GreeterService is a polite API. You will love it.
export class GreeterService {
	constructor(readonly client: Client) {}
	
	// GetGreetings gets a range of saved Greetings.
	async getGreetings(getGreetingsRequest?: GetGreetingsRequest, modifyHeaders?: HeadersFunc): Promise<GetGreetingsResponse> {
		if (getGreetingsRequest == null) {
			getGreetingsRequest = new GetGreetingsRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'GreeterService.GetGreetings', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(getGreetingsRequest),
		})
		if (response.status !== 200) {
			throw new Error(`GreeterService.GetGreetings: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new GetGreetingsResponse(json);
		})
	}
	
	// Greet creates a Greeting for one or more people.
	async greet(greetRequest?: GreetRequest, modifyHeaders?: HeadersFunc): Promise<GreetResponse> {
		if (greetRequest == null) {
			greetRequest = new GreetRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'GreeterService.Greet', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(greetRequest),
		})
		if (response.status !== 200) {
			throw new Error(`GreeterService.Greet: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new GreetResponse(json);
		})
	}
	
}

// Ignorer gets ignored by the tooling.
export class Ignorer {
	constructor(readonly client: Client) {}
	
		async ignore(ignoreRequest?: IgnoreRequest, modifyHeaders?: HeadersFunc): Promise<IgnoreResponse> {
		if (ignoreRequest == null) {
			ignoreRequest = new IgnoreRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'Ignorer.Ignore', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(ignoreRequest),
		})
		if (response.status !== 200) {
			throw new Error(`Ignorer.Ignore: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new IgnoreResponse(json);
		})
	}
	
}

// Welcomer welcomes people.
export class Welcomer {
	constructor(readonly client: Client) {}
	
	// Welcome makes a welcome message for somebody.
	async welcome(welcomeRequest?: WelcomeRequest, modifyHeaders?: HeadersFunc): Promise<WelcomeResponse> {
		if (welcomeRequest == null) {
			welcomeRequest = new WelcomeRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'Welcomer.Welcome', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(welcomeRequest),
		})
		if (response.status !== 200) {
			throw new Error(`Welcomer.Welcome: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new WelcomeResponse(json);
		})
	}
	
}



// GetGreetingsRequest is the request object for GreeterService.GetGreetings.
export class GetGreetingsRequest {
	constructor(data?: any) {
		if (data) {
		
			
				
					this.page = new services.Page(data.page);
				
			
		
		}
	}

	// Page describes which page of data to get.
	page?: services.Page;

}

// GetGreetingsResponse is the respponse object for GreeterService.GetGreetings.
export class GetGreetingsResponse {
	constructor(data?: any) {
		if (data) {
		
			
				
					if (data.greetings) {
						this.greetings = []
						for (let i = 0; i < data.greetings.length; i++) {
							this.greetings.push(new Greeting(data.greetings[i]));
						}
					}
				
			
		
			
			this.error = data.error;
			
		
		}
	}

		greetings?: Greeting[];

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// GreetRequest is the request object for GreeterService.Greet.
export class GreetRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.names = data.names;
			
		
		}
	}

	// Names are the names of the people to greet.
	names?: string[];

}

// GreetResponse is the response object containing a person's greeting.
export class GreetResponse {
	constructor(data?: any) {
		if (data) {
		
			
				
					this.greeting = new Greeting(data.greeting);
				
			
		
			
			this.error = data.error;
			
		
		}
	}

	// Greeting is the generated Greeting.
	greeting?: Greeting;

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// Greeting contains the pleasentry.
export class Greeting {
	constructor(data?: any) {
		if (data) {
		
			
			this.text = data.text;
			
		
		}
	}

	// Text is the message.
	text: string = stringDefault;

}

// IgnoreRequest should get ignored.
export class IgnoreRequest {
	constructor(data?: any) {
		if (data) {
		
		}
	}

}

// IgnoreResponse should get ignored.
export class IgnoreResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.error = data.error;
			
		
		}
	}

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

export class Page {
	constructor(data?: any) {
		if (data) {
		
			
			this.cursor = data.cursor;
			
		
			
			this.orderField = data.orderField;
			
		
			
			this.orderAsc = data.orderAsc;
			
		
		}
	}

		cursor: string = stringDefault;

		orderField: string = stringDefault;

		orderAsc: boolean = booleanDefault;

}

// WelcomeRequest is the request object for Welcomer.Welcome.
export class WelcomeRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.to = data.to;
			
		
			
			this.name = data.name;
			
		
			
			this.times = data.times;
			
		
			
			this.newCustomer = data.newCustomer;
			
		
		}
	}

	// To is the address of the person to send the message to.
	to: string = stringDefault;

	// Name is the name of the person to welcome.
	name: string = stringDefault;

	// The number of times to send the message.
	times: number = numberDefault;

	// NewCustomer indicates whether this is a new customer or not.
	newCustomer: boolean = booleanDefault;

}

// WelcomeResponse is the response object for Welcomer.Welcome.
export class WelcomeResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.message = data.message;
			
		
			
			this.error = data.error;
			
		
		}
	}

	// Message is the welcome message.
	message: string = stringDefault;

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}


// these defaults make the template easier to write.
const stringDefault = ''
const numberDefault = 0
const booleanDefault = false 
const anyDefault = null
